# replace all spaces with %20
def replace(str)
  str.split(' ').join('%20')
end

# 2 strings are anagrams
# 1st way to do it
def anagrams?(str1, str2)
  str1.chars.sort == str2.chars.sort
end

# 2nd way to do it
def anagrams?(str1, str2)
  str1.chars.all? do |letter|
  str2.chars.include?(letter)
end

# Remove string dups without an additional buffer
def remove_dups(str)
  res = ''
  dups = ''
  i = 0
  while i < str.length
    j = i + 1
    while j < str.length
      dups << str[i] if str[i] == str[j]
      res << str[i] if str[i] == str[j]
      j += 1
    end
    res << str[i] unless dups.include?(str[i])
    i += 1
    end
    
  res
end

# Reverse a string
# transverse the whole string method
def my_reverse(str)
  res = ''
  str.each_char do |letter|
    res.shift(letter)
  end
  
  res
end

# in place method
def my_reverse(str)
  i = 0
  j = 0
  
  while i < j
    str[i], str[j] = str[j], str[i]
    i += 1
    j -= 1
  end
  
  str
end

# check for all uniques
def uniques?(str)
  alpha = ('a'..'z').to_a
  str.each_char do |letter|
    return false unless alpha.delete(letter)
end
  
  true
end

def uniques?(str)
  alpha = Hash.new(0)
  str.each_char do |letter|
    alpha[letter] += 1
  end
  alpha.values.none? { |v| v > 1 }
end

# Assume you have a method isSubstring which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring (i.e., “waterbottle” is a rotation of “erbottlewat”).

def is_substring?(str1, str2)
  return false unless str1.length == str2.length
  (str2 + str2).include?(str1)
end

# rotate array by 90 degrees
def rotate_arr(a)
    res = []
    a.transpose.each do |row|
        res << row.reverse
    end
    res
end

# find 1st duplicate of an array
def firstDuplicate(a)
    dups = Hash.new(0)
    idx = Hash.new
    index = a.length
    
    a.each_with_index do |el, i|
       dups[el] += 1
        idx[el] = i unless dups[el] > 2
    end
    
    return -1 unless dups.values.any? {|val| val > 1}
    
    dup_vals = dups.map {|k, v| k if v > 1}.compact
    dup_vals.each do |el|
       index = idx[el] if idx[el] < index
    end
    
    a[index]
end

# find the nth to last element in a singly linked list
def nth_to_last(head, n)
  return nil if head.nil? || n < 1
  p1 = head
  p2 = head
  i = 0
  
  while i < n - 1
    return nil if p2.nil?
    p2 = p2.next
  end
  
  while p2.next
    p1 = p1.next
    p2 = p2.next
  end
  
  p1
end

# delete duplicates in a singly linked list
def delete_dupes(head)
  return nil if head.nil?
  
  previous = head
  current = previous.next
  while current
    runner = head
    while runner != current
      if runner.val == current.val
        tmp = current.next
        previous.next = tmp
        current = tmp
       end
       if runner == current
        previous = current
        current = current.next
       end
    end
  end
end

def is_palendrome?(str)
  idx1 = 0
  idx2 = -1
  
  while idx1 < str.length / 2
    return false if str[idx1] != str[idx2]
    idx1 += 1
    idx2 -= 1
  end
  
  true
end

print is_palendrome?("aca")
print is_palendrome?("baaa")

Def longest_sunstring(str)
  Sub_arr = [str[0]]
  Longest = 0
  Str[1..-1].each_char do |letter|
     Unless sub_arr.include?(letter)
         Sub_arr.push(letter)
     Else
          Longest = sub_arr.length if sur_arr.length > longest 
           Sub_arr = [letter]
      End
   End
  Longest
End
